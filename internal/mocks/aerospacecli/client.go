// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/cristianoliveira/aerospace-ipc/pkg/client (interfaces: AeroSpaceConnection)
//
// Generated by this command:
//
//	mockgen -package aerospacecli_mock github.com/cristianoliveira/aerospace-ipc/pkg/client AeroSpaceConnection
//

// Package aerospacecli_mock is a generated GoMock package.
package aerospacecli_mock

import (
	reflect "reflect"

	client "github.com/cristianoliveira/aerospace-ipc/pkg/client"
	gomock "go.uber.org/mock/gomock"
)

// MockAeroSpaceConnection is a mock of AeroSpaceConnection interface.
type MockAeroSpaceConnection struct {
	ctrl     *gomock.Controller
	recorder *MockAeroSpaceConnectionMockRecorder
	isgomock struct{}
}

// MockAeroSpaceConnectionMockRecorder is the mock recorder for MockAeroSpaceConnection.
type MockAeroSpaceConnectionMockRecorder struct {
	mock *MockAeroSpaceConnection
}

// NewMockAeroSpaceConnection creates a new mock instance.
func NewMockAeroSpaceConnection(ctrl *gomock.Controller) *MockAeroSpaceConnection {
	mock := &MockAeroSpaceConnection{ctrl: ctrl}
	mock.recorder = &MockAeroSpaceConnectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAeroSpaceConnection) EXPECT() *MockAeroSpaceConnectionMockRecorder {
	return m.recorder
}

// CheckServerVersion mocks base method.
func (m *MockAeroSpaceConnection) CheckServerVersion() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckServerVersion")
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckServerVersion indicates an expected call of CheckServerVersion.
func (mr *MockAeroSpaceConnectionMockRecorder) CheckServerVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckServerVersion", reflect.TypeOf((*MockAeroSpaceConnection)(nil).CheckServerVersion))
}

// CloseConnection mocks base method.
func (m *MockAeroSpaceConnection) CloseConnection() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloseConnection")
	ret0, _ := ret[0].(error)
	return ret0
}

// CloseConnection indicates an expected call of CloseConnection.
func (mr *MockAeroSpaceConnectionMockRecorder) CloseConnection() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseConnection", reflect.TypeOf((*MockAeroSpaceConnection)(nil).CloseConnection))
}

// GetServerVersion mocks base method.
func (m *MockAeroSpaceConnection) GetServerVersion() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServerVersion")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetServerVersion indicates an expected call of GetServerVersion.
func (mr *MockAeroSpaceConnectionMockRecorder) GetServerVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServerVersion", reflect.TypeOf((*MockAeroSpaceConnection)(nil).GetServerVersion))
}

// GetSocketPath mocks base method.
func (m *MockAeroSpaceConnection) GetSocketPath() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSocketPath")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSocketPath indicates an expected call of GetSocketPath.
func (mr *MockAeroSpaceConnectionMockRecorder) GetSocketPath() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSocketPath", reflect.TypeOf((*MockAeroSpaceConnection)(nil).GetSocketPath))
}

// SendCommand mocks base method.
func (m *MockAeroSpaceConnection) SendCommand(command string, args []string) (*client.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendCommand", command, args)
	ret0, _ := ret[0].(*client.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendCommand indicates an expected call of SendCommand.
func (mr *MockAeroSpaceConnectionMockRecorder) SendCommand(command, args any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendCommand", reflect.TypeOf((*MockAeroSpaceConnection)(nil).SendCommand), command, args)
}
