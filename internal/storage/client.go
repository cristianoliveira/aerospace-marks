package storage

import (
	"database/sql"
	"embed"
	"fmt"
	"os"
	"strconv"

	"github.com/cristianoliveira/aerospace-marks/internal/constants"
	"github.com/cristianoliveira/aerospace-marks/internal/logger"
	"github.com/pressly/goose/v3"
)

//go:embed db/migrations/*.sql
var embedMigrations embed.FS

type Mark struct {
	WindowID string `json:"window_id"`
	Mark     string `json:"mark"`
}

func (m *Mark) GetWindowID() (int, error) {
	if m == nil {
		return 0, fmt.Errorf("mark is nil")
	}
	if m.WindowID == "" {
		return 0, fmt.Errorf("window ID is empty")
	}
	id, err := strconv.Atoi(m.WindowID)
	if err != nil {
		return 0, fmt.Errorf("invalid window ID: %s", m.WindowID)
	}
	return id, nil
}

type DbResult interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

type StorageConfig struct {
	// Path to the database file
	DbPath string

	// Name of the database file
	DbName string
}

type StorageDbClient interface {
	// Get all marks as a list
	// This function will return all marks in the database
	// if no marks are found, it will return an empty slice
	QueryAll(query string, args ...any) ([]Mark, error)
	// Get ONE mark by query
	// This function will return the first mark that matches the query
	// if multiple marks match the query, it will return an error
	QueryOne(query string, args ...any) (*Mark, error)
	// Execute a query
	// This function will execute a query and return a raw result
	Execute(query string, args ...any) (DbResult, error)
	// Close the database connection
	Close() error
	// GetStorageConfig returns the storage configuration
	GetStorageConfig() StorageConfig
}

type StorageClient struct {
	dbConfig StorageConfig
	db       *sql.DB
}

func (c *StorageClient) QueryAll(query string, args ...any) ([]Mark, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("querying all marks", query, args)

	rows, err := c.db.Query(query)
	if err != nil {
		return nil, err
	}
	defer func() {
		err := rows.Close()
		if err != nil {
			log.LogError("failed to close rows", err)
		}
	}()

	var marks []Mark
	for rows.Next() {
		var mark Mark
		if err := rows.Scan(&mark.WindowID, &mark.Mark); err != nil {
			return nil, err
		}
		marks = append(marks, mark)
	}

	log.LogInfo("result", log.AsJson(marks))

	return marks, nil
}

func (c *StorageClient) QueryOne(query string, args ...any) (*Mark, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("querying one mark", query, args)

	row := c.db.QueryRow(query, args...)

	var mark Mark
	if err := row.Scan(&mark.WindowID, &mark.Mark); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	log.LogInfo("result", mark)
	return &mark, nil
}

func (c *StorageClient) Execute(query string, args ...any) (DbResult, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("executing query", query, args)
	result, err := c.db.Exec(query, args...)
	if err != nil {
		return nil, err
	}

	log.LogInfo("result", result)
	return result, nil
}

func (c *StorageClient) Close() error {
	if c.db == nil {
		return fmt.Errorf("database connection is not initialized")
	}
	return c.db.Close()
}

func (c *StorageClient) runMigrations() error {
	appLog := logger.GetDefaultLogger()
	goose.SetLogger(appLog.(goose.Logger))

	// Set the goose provider to use embedded migrations
	goose.SetBaseFS(embedMigrations)

	// Run migrations
	if err := goose.SetDialect("sqlite3"); err != nil {
		appLog.LogError("failed to set goose dialect", err)
		return err
	}

	if err := goose.Up(c.db, "db/migrations"); err != nil {
		appLog.LogError("failed to run migrations", err)
		return err
	}

	appLog.LogInfo("migrations completed successfully")
	return nil
}

func (c *StorageClient) GetVersion() (int64, error) {
	appLog := logger.GetDefaultLogger()
	goose.SetLogger(appLog.(goose.Logger))

	// Set the goose provider to use embedded migrations
	goose.SetBaseFS(embedMigrations)

	if err := goose.SetDialect("sqlite3"); err != nil {
		appLog.LogError("failed to set goose dialect", err)
		return 0, err
	}

	version, err := goose.GetDBVersion(c.db)
	if err != nil {
		appLog.LogError("failed to get database version", err)
		return 0, err
	}

	appLog.LogInfo("database version", version)
	return version, nil
}

// GetStorageConfig returns the storage configuration
func (c *StorageClient) GetStorageConfig() StorageConfig {
	log := logger.GetDefaultLogger()
	log.LogInfo("getting storage configuration", "config", c.dbConfig)
	return c.dbConfig
}

// --CONNECTOR--

type DatabaseConnector interface {
	// Connect to the database and retun a MarksDatabaseClient
	Connect() (StorageDbClient, error)
}

type MarksDatabaseConnector struct{}

func (c *MarksDatabaseConnector) Connect() (StorageDbClient, error) {
	log := logger.GetDefaultLogger()
	dbConfig := GetDatabaseConfig()

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(dbConfig.DbPath, 0755); err != nil {
		return nil, err
	}

	dbPath := fmt.Sprintf("%s/storage.db", dbConfig.DbPath)

	log.LogInfo("connecting to database", dbPath)
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, err
	}

	client := &StorageClient{
		dbConfig: dbConfig,
		db:       db,
	}

	// Run migrations to ensure database is up to date
	if err := client.runMigrations(); err != nil {
		log.LogError("failed to run migrations", err)
		return nil, err
	}

	return client, nil
}

func GetDatabaseConfig() StorageConfig {
	dbDir := fmt.Sprintf("%s/.local/state/aerospace-marks", os.Getenv("HOME"))

	configDbPath := os.Getenv(constants.EnvAeroSpaceMarksDbPath)
	if configDbPath != "" {
		dbDir = configDbPath
	}

	return StorageConfig{
		DbPath: dbDir,
		DbName: "storage.db",
	}
}

var DefaultConnector DatabaseConnector = &MarksDatabaseConnector{}
