package storage

import (
	"database/sql"
	"fmt"
	"os"

	"github.com/cristianoliveira/aerospace-marks/internal/logger"
)

type Mark struct {
	WindowID string `json:"window_id"`
	Mark     string `json:"mark"`
}

type DbResult interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

type StorageConfig struct {
	// Path to the database file
	DbPath string

	// Name of the database file
	DbName string
}

type StorageDbClient interface {
	// Get all marks as a list
	// This function will return all marks in the database
	// if no marks are found, it will return an empty slice
	QueryAll(query string, args ...any) ([]Mark, error)
	// Get ONE mark by query
	// This function will return the first mark that matches the query
	// if multiple marks match the query, it will return an error
	QueryOne(query string, args ...any) (*Mark, error)
	// Execute a query
	// This function will execute a query and return a raw result
	Execute(query string, args ...any) (DbResult, error)
	// Close the database connection
	Close() error
}

type StorageClient struct {
	db *sql.DB
}

func (c *StorageClient) QueryAll(query string, args ...any) ([]Mark, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("querying all marks", query, args)

	rows, err := c.db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var marks []Mark
	for rows.Next() {
		var mark Mark
		if err := rows.Scan(&mark.WindowID, &mark.Mark); err != nil {
			return nil, err
		}
		marks = append(marks, mark)
	}

	log.LogInfo("result", log.AsJson(marks))

	return marks, nil
}

func (c *StorageClient) QueryOne(query string, args ...any) (*Mark, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("querying one mark", query, args)

	row := c.db.QueryRow(query, args...)

	var mark Mark
	if err := row.Scan(&mark.WindowID, &mark.Mark); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	log.LogInfo("result", mark)
	return &mark, nil
}

func (c *StorageClient) Execute(query string, args ...any) (DbResult, error) {
	log := logger.GetDefaultLogger()
	log.LogInfo("executing query", query, args)
	result, err := c.db.Exec(query, args...)
	if err != nil {
		return nil, err
	}

	log.LogInfo("result", result)
	return result, nil
}

func (c *StorageClient) Close() error {
	if c.db == nil {
		return fmt.Errorf("database connection is not initialized")
	}
	return c.db.Close()
}

func (c *StorageClient) createTableIfNotExists() error {
	// Marks are unique to a window, so we can use the window_id as a unique key
	// but one window may have multiple marks
	query := `
	CREATE TABLE IF NOT EXISTS marks (
		window_id TEXT,
		mark TEXT,
		constraint marks_pk PRIMARY KEY (window_id, mark)
	);
	`
	_, err := c.db.Exec(query)
	return err
}

// --CONNECTOR--

type DatabaseConnector interface {
	// Connect to the database and retun a MarksDatabaseClient
	Connect() (StorageDbClient, error)
}

type MarksDatabaseConnector struct{}

func (c *MarksDatabaseConnector) Connect() (StorageDbClient, error) {
	log := logger.GetDefaultLogger()
	dbConfig := GetDatabaseConfig()

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(dbConfig.DbPath, 0755); err != nil {
		return nil, err
	}

	dbPath := fmt.Sprintf("%s/storage.db", dbConfig.DbPath)

	log.LogInfo("connecting to database", dbPath)
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, err
	}

	client := &StorageClient{db: db}
	if err := client.createTableIfNotExists(); err != nil {
		log.LogError("failed to create table", err)
		return nil, err
	}

	return client, nil
}

func GetDatabaseConfig() StorageConfig {
	dbDir := fmt.Sprintf("%s/.local/state/aerospace-marks", os.Getenv("HOME"))

	configDbPath := os.Getenv("AEROSPACE_MARKS_DB_PATH")
	if configDbPath != "" {
		dbDir = fmt.Sprintf("%s", configDbPath)
	} 

	return StorageConfig{
		DbPath: dbDir,
		DbName: "storage.db",
	}
}

var DefaultConnector DatabaseConnector = &MarksDatabaseConnector{}
